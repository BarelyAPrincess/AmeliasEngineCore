import java.text.SimpleDateFormat

apply plugin: 'java'
apply plugin: 'groovy'
apply plugin: 'idea'
apply plugin: 'eclipse'
apply plugin: 'com.github.hierynomus.license'
apply plugin: 'checkstyle'
apply plugin: 'application'
apply plugin: 'ch.raffael.pegdown-doclet'
apply from: project.file( 'etc/publlsh.gradle' )

defaultTasks 'clean', 'build'

buildscript {
	repositories {
		jcenter()
		mavenCentral()
		maven {
			url "https://plugins.gradle.org/m2/"
		}
	}

	dependencies {
		classpath "gradle.plugin.nl.javadude.gradle.plugins:license-gradle-plugin:0.14.0"
		classpath 'ch.raffael.pegdown-doclet:pegdown-doclet:1.3'
	}
}

allprojects {
	repositories {
		jcenter()
		mavenCentral()
		maven {url 'https://jitpack.io'}
	}

	compileGroovy {options.encoding = "UTF-8"}
	compileJava {options.encoding = 'UTF-8'}
	javadoc {options.encoding = "UTF-8"}

	license {
		header rootProject.file( 'etc/HEADER' )
		ignoreFailures true
		strictCheck true
		mapping 'yaml', 'SCRIPT_STYLE'
		mapping 'yml', 'SCRIPT_STYLE'
		excludes( ['**/*.archive',
		           '**/*.md5',
		           '**/*.txt',
		           '**/*.bmp',
		           '**/*.png',
		           '**/*.jpg',
		           '**/*.yaml',
		           '**/*.yml',
		           '**/*.properties',
		           '**/banner.txt'] )
		ext.year = Calendar.getInstance().get( Calendar.YEAR )
		ext.name = 'Amelia Sara Greene'
		ext.email = 'barelyaprincess@gmail.com'
	}

	checkstyle {
		configFile = rootProject.file( 'etc/checkstyle.xml' )
		configProperties = ["basedir": project.projectDir]
	}

	configurations {
		required
	}

	dependencies {
		configurations.compile.extendsFrom( configurations.required )
	}

	task dependenyBundler {
		doFirst {
			def depend = configurations.required.collect {it.isDirectory() ? it : zipTree( it )}
			if ( depend.size > 0 )
			{
				println 'Bundled required libs into jar: ' + depend
				rootProject.jar.from( depend )
			}
		}
	}

	jar.dependsOn dependenyBundler
}

def rootDir = rootProject.rootDir

subprojects {
	buildDir = new File( rootDir, '/build/' )
	libsDirName = new File( rootDir, '/build/dist/' )
	artifacts {archives jar}
}

// Tells Gradle to include the sourceSets from all subprojects into the main
sourceSets {
	main {
		java {
			rootProject.getSubprojects().each {
				it.sourceSets.main.java.srcDirs.each {
					srcDir it
				}
			}
		}
	}
}

dependencies {
	testCompile( group: 'junit', name: 'junit', version: '4.12' ) {
		exclude group: 'org.hamcrest'
	}
	testCompile 'org.hamcrest:hamcrest-library:1.3'

	compile group: 'com.google.code.findbugs', name: 'jsr305', version: '1.3.9'

	/* Console ANSI Colors */
	required group: 'org.fusesource.jansi', name: 'jansi', version: '1.11'

	required group: 'net.sf.jopt-simple', name: 'jopt-simple', version: '4.7'

	required 'org.codehaus.groovy:groovy-all:3.0.4'

	// Networking
	required group: 'javax.servlet', name: 'javax.servlet-api', version: '4.0.1'
	required group: 'io.netty', name: 'netty-all', version: '4.1.39.Final'
	// SSL
	required group: 'org.bouncycastle', name: 'bcprov-jdk15on', version: '1.53'
	required group: 'org.bouncycastle', name: 'bcpkix-jdk15on', version: '1.53'
}

sourceCompatibility = '1.8'
targetCompatibility = '1.8'

Properties buildProperties = getBuildProperties();

mainClassName = "io.amelia.engine.EntryPoint"
def rawVersion = buildProperties.getProperty( "versionMajor" ) + "." + buildProperties.getProperty( "versionMinor" ) + "." + buildProperties.getProperty( "versionRevision" )
def jenkins_build = System.getenv( "BUILD_NUMBER" )
def travis_build = System.getenv( "TRAVIS_BUILD_NUMBER" )
def buildNumber = '0'

group 'io.amelia.engine'
description = 'Amelia\'s Engine Core is an extensive groovy driven application framework with endless posibilities from simple scripts to complete web servers.'

distsDirName = 'dist'
libsDirName = 'dist'

if ( System.getenv( "RELEASE" ) != null )
{
	version = buildProperties.getProperty( "versionMajor" ) + "." + buildProperties.getProperty( "versionMinor" ) + "." + buildProperties.getProperty( "versionRevision" ) + "-" + System.getenv( "RELEASE" )
}
else if ( jenkins_build != null )
{
	version = rawVersion + '-jenkins+B' + jenkins_build
	buildNumber = jenkins_build
}
else if ( travis_build != null )
{
	version = rawVersion + '-travis+B' + travis_build
	buildNumber = travis_build
}
else
{
	version = rawVersion + '-git+H' + gitDescribe()
}

def gitDescribe()
{
	try
	{
		def stdout = new ByteArrayOutputStream()
		exec {
			commandLine 'git', 'rev-parse', '--short', 'HEAD'
			standardOutput = stdout
		}
		return stdout.toString().trim()
	}
	catch ( Throwable e )
	{
		return "unknown"
	}
}

def getBuildProperties()
{
	try
	{
		File propFile = new File( "./src/main/resources/build.properties" );

		if ( !propFile.exists() )
			propFile.createNewFile();

		Properties props = new Properties()
		props.load( new FileInputStream( propFile ) )
		return props
	}
	catch ( Throwable e )
	{
		e.printStackTrace()
		return null;
	}
}

eclipse {
	project {name = buildProperties.getProperty( "gitRepo", "AmeliasEngineCore" )}
}

jar {
	manifest {
		attributes 'Implementation-Title': buildProperties.getProperty( "productName", 'Amelia\'s Engine Core' )
		attributes 'Implementation-Version': version
		attributes 'Implementation-Vendor': buildProperties.getProperty( "devName", 'Amelia Sara Greene' )
		attributes 'Implementation-Vendor-Id': buildProperties.getProperty( "devEmail", 'BarelyAPrincess@gmail.com' )
		attributes 'Main-Class': mainClassName
	}
}

task sourcesArchive( type: Zip ) {
	classifier = 'sources'
	from sourceSets.main.allSource
}

task javadocArchive( type: Zip, dependsOn: 'javadoc' ) {
	classifier = 'javadoc'
	from javadoc.destinationDir
}

/**
 * Writes the project dependencies to a resource file for dependency injection within the application*/
task writeDependenciesFile {
	doFirst {
		def allDependencies = []
		rootProject.getAllprojects().each {
			allDependencies += it.getConfigurations().getByName( "runtime" ).getAllDependencies().withType( ExternalModuleDependency )

			// Remove all dependencies that were already bundled into the jar file
			allDependencies.removeAll( it.getConfigurations().getByName( "required" ).getAllDependencies().withType( ExternalModuleDependency ) )
		}

		def output = ""
		allDependencies.unique().each {
			output += it.group + ":" + it.name + ":" + it.version + "\n"
		}

		def file = file( "src/main/resources/dependencies.txt" )
		file.parentFile.mkdirs()
		def fos = new FileOutputStream( file )
		fos.write( ( byte[] ) output.getBytes() )
		fos.close()
	}
}

task writePropertiesFile {
	doFirst {
		SimpleDateFormat sdf = new SimpleDateFormat( "EEE, d MMM yyyy HH:mm:ss Z" )

		Properties props = new Properties()
		props.load( new FileInputStream( file( "src/main/resources/build.properties" ) ) )
		props.setProperty( "project.builtOn", sdf.format( new Date() ) )
		props.setProperty( "project.build", buildNumber )
		props.setProperty( "project.version", version.toString() )

		File f2 = file( "build/dist/build.properties" )
		File f3 = file( "build/resources/main/build.properties" )
		f2.parentFile.mkdirs()
		f3.parentFile.mkdirs()
		OutputStream out2 = new FileOutputStream( f2 )
		OutputStream out3 = new FileOutputStream( f3 )
		props.store( out2, "Build Properties File" )
		props.store( out3, "Build Properties File" )
	}
}

build.dependsOn writeDependenciesFile
jar.dependsOn writePropertiesFile

artifacts {archives jar, sourcesArchive, javadocArchive}
